use std::mem::size_of;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct ORef(usize);

impl ORef {
	const TAG_BITS: usize = 2;

	const PAYLOAD_BITS: usize = 8*size_of::<Self>() - Self::TAG_BITS;

	const SHIFT: usize = Self::TAG_BITS;
}

struct Fixnum(usize);

impl Fixnum {
	const MIN: isize = -(1 << (ORef::PAYLOAD_BITS - 1));

	const MAX: isize = (1 << (ORef::PAYLOAD_BITS - 1)) - 1;
}

impl From<Fixnum> for ORef {
	fn from(n: Fixnum) -> Self { Self(n.0) }
}

impl TryFrom<isize> for Fixnum {
	type Error = ();

	fn try_from(n: isize) -> Result<Self, Self::Error> {
		// Bounds check `Fixnum::MIN <= n <= Fixnum::MAX` from Hacker's Delight 4-1:
		if (n - Fixnum::MIN) as usize <= (Fixnum::MAX - Fixnum::MIN) as usize {
			Ok(Fixnum((n as usize) << ORef::SHIFT))
		} else {
			Err(())
		}
	}
}

impl From<Fixnum> for isize {
	fn from(n: Fixnum) -> Self { (n.0 as Self) >> ORef::SHIFT }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn fixnum_try_from_isize() {
    	assert!(Fixnum::try_from(0isize).is_ok());

    	assert!(Fixnum::try_from(5isize).is_ok());
    	assert!(Fixnum::try_from(-5isize).is_ok());

    	assert!(Fixnum::try_from(Fixnum::MIN).is_ok());
    	assert!(Fixnum::try_from(Fixnum::MAX).is_ok());
    	
    	assert!(Fixnum::try_from(Fixnum::MIN - 1).is_err());
    	assert!(Fixnum::try_from(Fixnum::MAX + 1).is_err());
    }

    #[test]
    fn isize_from_fixnum() {
    	assert_eq!(isize::from(Fixnum::try_from(0isize).unwrap()), 0);

    	assert_eq!(isize::from(Fixnum::try_from(5isize).unwrap()), 5);
    	assert_eq!(isize::from(Fixnum::try_from(-5isize).unwrap()), -5);

    	assert_eq!(isize::from(Fixnum::try_from(Fixnum::MIN).unwrap()), Fixnum::MIN);
    	assert_eq!(isize::from(Fixnum::try_from(Fixnum::MAX).unwrap()), Fixnum::MAX);
    }
}
